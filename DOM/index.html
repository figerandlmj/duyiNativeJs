<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>DOM</title>
	<script src="index.js"></script>
</head>
<body>
	DOM(document oaject model)：一套方法的集合的统称，有利于操作html和xml
	xml -> xhtml -> html
	xml：标签自定义，表示数据格式，这种格式有利于数据操作，后被json取代
	<!-- <student>
		<name>张三</name>
		<age>25</age>
	</student> -->

	sublime emmet安装 
	preferences -> package control -> install package -> emmet、js prettify
	快捷方式 div>p^span
	<!-- <div>
		<p></p>
		<span></span>
	</div> -->
	别的编辑器vsCode webstorm

	节点选择器：
	var div = document.getElementById('div');//ie8以下，id不区分大小写，当id没有时取name的值
	var div = document.getElementsByTagName('div');//类数组[],没有兼容性问题
	var div = document.getElementsByClassName('div');//ie8及以下不兼容
	var div = document.getElementsByName('div');//低版本只有部分标签name可生效（表单、表单元素、img、iframe）
	<!-- ie6\7不兼容且不是实时的 -->
	var demo = document.querySelector('div>span strong.demo');
	var demo = document.querySelectorAll('div>span strong.demo');//类数组

	遍历节点树：
	span.parentNode      父节点
	span.childNodes      子节点们
	span.firstChild      第一个子节点
	span.lastChild       最后一个子节点
	span.nextSibling     下一个兄弟节点
	span.previousSibling 前一个兄弟节点 

	遍历元素节点树：除了children,ie9及以下都没实现
	span.parentElement      元素父节点
	span.children           元素子节点
	span.childElementCount  元素子节点个数，相当于children.length
	firstElementChild       第一个元素子节点
	lastElementChild        最后一个元素子节点
	nextElementSibling      下一个元素兄弟节点
	previousElementSibling  前一个元素兄弟节点

	节点的类型：               nodeType返回值
	元素节点                   1
	属性节点                   2
	文本节点                   3
	注释节点                   8
	document                   9
	DocumentFragment 文档碎片  11
	
	节点的属性方法：
	nodeName        元素的标签名，只读
	nodeValue       节点值（文本节点、注释节点），可读写
	nodeType        节点类型

	attributes      属性节点的集合 [].name 可写  [].value 可读写

	hasChildNodes() 是否有子节点，返回true/false

	DOM节点树：
	===============================================================================
			        Document	   HTMLDocument	
			                       XMLDocument

			        CharacterData  Text
						           Comment注释
	node ->
	  		        Element        HTMLElement   ->     HTMLHeadElement
	  v					           XMLElement           HTMLBodyElement
	  									                HTMLTitleElement
	ElementTarget   Attr							    HTMLParagraphElement
											            HTMLInputElement
	  v										            HTMLTableElement
											            ...
	Object  
	=================================================================================

	getElmentsByTagName('*') //所有元素标签

	document.body
	document.head
	document.documentElement  //html

						   定义在此
	getElementById         Document.prototype
	getElementsByName      HTMLDocument.prototype     
	getElementsByTagName   Document.prototype 和 HTMLDocument.prototype   
	getElementsByClassName
	querySlector
	querySlectorAll

	增加：
	document.createElement('div');               元素节点
	document.createTextNode('hello');            文本节点
	document.createComment('this is comment');   注释节点
	document.createDocumentFragment('div');      文档碎片

	插入：
	parentnode.appendChild();//把没有的插入类似push,把已有的插入类似剪切
	parentnode.insertBefore(a, b);//insert a before b

	删除：
	parent.removeChild();//返回剪切出来的
	child.remove();//返回undefined

	替换：
	parent.replaceChild(new, origin);返回剪切的origin

	Element节点属性方法：
	ele.innerHTML                     可读可写
	ele.innerText/textContent         会覆盖节点
	老firefox不兼容/老ie不兼容 
	ele.setAttribute('class', 'demo') 设置属性      
	ele.getAttribute()                获取属性  

	日期对象：纪元时间 1970.1.1开始 
	var date = new Date();
	计算时间戳用 getTime()

	定时器：
	setInterval: 时间不准 window上的方法 this指向window
	var timer = setInterval(function(){}, 1000);//返回的是定时器的唯一标识1,2...
	clearInterval(timer);

	setTimeout 延时多久执行
	var timer = setTimeout(function(){},1000);
	clearTimeout(timer);
	
	DOM基本操作：

	查看滚动条的滚动距离
	window.pageXOffset/pageYOffset //ie8及以下不兼容
	document.body.scrollLeft/scrollTop
	document.documentElement.scrollLeft/scrollTop 

	可视区窗口的尺寸
	window.innerWidth/innerHeight  //ie8及以下不兼容
	document.documentElement.clientWidth/clientHeight //标准模式下都兼容
	document.body.clientWidth/clientHeight
	document.compatMode: CSS1Compat/BackCompat  标准模式和怪异模式

	<!-- <!DOCTYPE html> -->  标准模式 DTD 没有事为怪异模式
	渲染模式
	怪异模式/混杂模式 兼容之前的浏览器

	查看元素的几何尺寸
	div.getBoundingClientRect() -> {width,height,top,right,bottom,left,...}  //兼容性好，width、height ie中没有，结果不是实时的
	
	div.offsetWidth/offsetHeight //视觉上的尺寸，包括padding,不报括margin
	div.offsetLeft/offsetTop  //相对有定位的父级的位置，若没有最近父级则返回的是相对文档body
	div.offsetParent  //返回最近的有定位的父级

	让滚动条滚动
	window.scroll(x, y)
	window.scrollTo(x, y)
	window.scrollBy(x, y) //在之前基础上累加滚动

	脚本化CSS：控制css

	DOM间接操作css
	div.style ：CSSStyleDeclaration css样式声明 类数组 可读可写 表示行间样式表
	div.style.width = "200px";
	div.style.backgroundColor = "green";
	div.style.cssFloat = "left";//float保留字
	div.style.borderWidth = "1px";//border符合属性

	获取计算样式（当前元素显示的样式） 只读 返回的是绝对值，没有相对单位 
	window.getComputedStyle(div, null)[prop]; //ie8及以下不兼容
	div.currentStyle //兼容ie8及以下 只读 不是绝对值

	window.getComputedStyle(div, "after").width //获取伪元素的属性
	
	动态改变样式：div.className = "active";
	
	事件: 交互体验的核心功能
	绑定事件处理函数
	1. div.onclick = function(){console.log('hello');}
		兼容性好 只能绑定一个函数 this指向div本身 等于在行间定义onclick="console.log('hello')"
	2. div.addEventListener('click', function(){}, false);
		ie9以下不兼容 可绑定多个处理函数 不能给同一个函数绑定多次 this指向div本身
	3. div.attachEvent('onclick', function(){});
	    ie独有，可绑定多个处理函数 可绑定同一个函数多次 this指向window
	    解决办法 div.attachEvent('onclick', function(){handle.call(div);});
	    		 function handle(){//this指向div}
	
	解除事件处理函数
	1. div.onclick = null;
	2. div.removeEventListener('click', fn, false);//与绑定函数保持一致
	3. div.detachEvent('onclick', fn);//与绑定函数保持一致

	事件处理模型：
	1. 冒泡（常规）
	    结构上子元素冒泡向父元素 自底向上
	2. 事件捕获  
	    自父元素至子元素 自顶向下  ie没有
	绑定两个事件处理函数时，一个冒泡一个捕获，先捕获后冒泡

	focus/blur/change/submit/reset/select 事件不冒泡

	取消事件冒泡
	e.stopPropagation();//ie不支持
	e.cancelBubble = true;//ie独有

	阻止默认事件：表单提交、a标签跳转、右键菜单...
	document.oncontextmenu = function(){
		console.log('hello');
		return false;//1
	}
	2. e.preventDefault();//ie9以下不兼容
	3. e.returnValue = false;//兼容ie
	<!-- <a href="javascript:void(false)">demo</a> //相当于return false; -->

	事件对象 事件源对象
	div.onclick = function(e){
		var event = e || window.event;//兼容ie
		var target = event.target || event.srcElement;
	}


</body>
</html>